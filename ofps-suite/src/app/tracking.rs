use super::utils::camera_controller::CameraController;
use super::{
    ConfigState, CreateDecoderUiConfig, CreateDecoderUiState, CreateEstimatorUiConfig,
    CreateEstimatorUiState, CreatePluginUi, OfpsAppContext, OfpsCtxApp,
};
use egui::*;
use epi::Frame;
use nalgebra as na;
use ofps::prelude::v1::*;
use serde::{Deserialize, Serialize};
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc, Mutex,
};
use wimrend::material::Material;
use wimrend::mesh::Mesh;
use wimrend::Renderer;

mod worker;

use worker::{EstimatorSettings, FrameState, TrackingSettings, TrackingState, TrackingWorker};

#[derive(Serialize, Deserialize)]
pub struct MotionTrackingConfig {
    decoder: (CreateDecoderUiConfig, bool),
    draw_grid: bool,
    view_fov: f32,
    view_focus_point: (f32, f32, f32),
    view_rot: (f32, f32, f32),
    view_dist: f32,
    estimators: Vec<(CreateEstimatorUiConfig, bool, EstimatorSettings)>,
    camera_fov_x: f32,
    camera_fov_y: f32,
}

pub struct MotionTrackingApp {
    create_decoder_state: CreateDecoderUiState,
    app_state: Option<TrackingWorker>,
    app_settings: TrackingSettings,
    estimator_uis: Vec<CreateEstimatorUiState>,
    camera_controller: CameraController,
    draw_grid: bool,
    config_state: ConfigState,
}

impl Default for MotionTrackingApp {
    fn default() -> Self {
        Self {
            create_decoder_state: Default::default(),
            app_state: None,
            app_settings: Default::default(),
            estimator_uis: vec![],
            camera_controller: Default::default(),
            draw_grid: true,
            config_state: Default::default(),
        }
    }
}

impl MotionTrackingApp {
    fn tracking_step(&mut self, renderer: &mut Renderer) {
        if let Some(state) = &self.app_state {
            // Load up any frames generated by worker onto GPU.
            for frame in state.frames_to_load.try_iter() {
                if let Ok(mut frame) = frame.lock() {
                    let frame = &mut *frame;
                    match frame {
                        FrameState::Pending(buf, height) => {
                            if let Ok(texture) = renderer.texture_from_rgba(
                                None,
                                bytemuck::cast_slice(&buf),
                                *height,
                            ) {
                                *frame = FrameState::Loaded(
                                    Material::textured(
                                        renderer.pipeline_manager_mut(),
                                        texture.into(),
                                    )
                                    .into(),
                                )
                            } else {
                                *frame = FrameState::Pending(vec![], 0);
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    fn render(&mut self, renderer: &mut Renderer) {
        self.camera_controller.on_render(renderer);

        if self.draw_grid {
            let range = 10isize;

            let line_colour = na::matrix![0.1; 0.1; 0.1; 1.0];
            let line_thickness = 2.0;

            for v in -range..=range {
                let v = v as f32;
                let range = range as f32;
                renderer.line(
                    na::matrix![v; -range; 0.0].into(),
                    na::matrix![v; range; 0.0].into(),
                    line_thickness,
                    line_colour,
                );
                renderer.line(
                    na::matrix![-range; v; 0.0].into(),
                    na::matrix![range; v; 0.0].into(),
                    line_thickness,
                    line_colour,
                );
            }
        }

        let (offset_factor, x_scale) = {
            let intrinsics = self.app_settings.camera.intrinsics();
            (
                intrinsics[(1, 1)] * 0.5,
                intrinsics[(1, 1)] / intrinsics[(0, 0)],
            )
        };

        // Render any layered frames
        if let Some(Ok(app_state)) = self.app_state.as_ref().map(|a| a.worker.read()) {
            for (state, settings) in app_state
                .estimators
                .iter()
                .zip(self.app_settings.settings.iter())
                .filter_map(|(v, (_, _, s))| v.as_ref().zip(Some(s)))
            {
                let scale = settings.camera_offset / offset_factor;

                for (pos, rot, mat) in state.layered_frames() {
                    if let Ok(mat) = mat.lock() {
                        // Must ensure the frame is loaded.
                        if let FrameState::Loaded(mat) = &*mat {
                            renderer.obj(
                                Mesh::centered_quad(),
                                (pos * settings.scale_factor)
                                    + rot * na::matrix![0.0; settings.camera_offset; 0.0],
                                rot * na::UnitQuaternion::from_euler_angles(
                                    -90.0f32.to_radians(),
                                    0.0,
                                    0.0,
                                ),
                                na::matrix![x_scale * scale; scale; 1.0],
                                na::matrix![1.0; 1.0; 1.0; 1.0],
                                mat.clone(),
                            );
                        }
                    }
                }
            }
        }
    }

    fn load_cfg(
        &mut self,
        ofps_ctx: &OfpsAppContext,
        MotionTrackingConfig {
            decoder,
            draw_grid,
            view_fov,
            view_focus_point,
            view_rot,
            view_dist,
            estimators,
            camera_fov_x,
            camera_fov_y,
        }: MotionTrackingConfig,
    ) {
        self.draw_grid = draw_grid;
        self.camera_controller.fov_y = view_fov;
        self.camera_controller.focus_point =
            na::Vector3::new(view_focus_point.0, view_focus_point.1, view_focus_point.2).into();
        self.camera_controller.rot =
            na::UnitQuaternion::from_euler_angles(view_rot.0, view_rot.1, view_rot.2);
        self.camera_controller.dist = view_dist;

        self.create_decoder_state.config = decoder.0;

        self.app_settings.camera = StandardCamera::new(camera_fov_x, camera_fov_y);
        self.app_settings.settings.clear();

        for (cfg, loaded, settings) in estimators {
            let mut ui = CreateEstimatorUiState::default();
            ui.config = cfg;

            let plugin = if loaded {
                match EstimatorPlugin::do_create(ofps_ctx, &mut ui) {
                    Ok(estimator) => Some(estimator),
                    _ => None,
                }
            } else {
                None
            };

            self.estimator_uis.push(ui);

            let loaded = Arc::from(AtomicBool::new(plugin.is_some()));

            self.app_settings
                .settings
                .push((Arc::from(Mutex::new(plugin)), loaded, settings))
        }

        self.app_state = if decoder.1 {
            match DecoderPlugin::do_create(ofps_ctx, &mut self.create_decoder_state) {
                Ok(decoder) => Some(TrackingState::worker(decoder, self.app_settings.clone())),
                _ => None,
            }
        } else {
            None
        };
    }

    fn save_cfg(&self) -> MotionTrackingConfig {
        let (camera_fov_x, camera_fov_y) = self.app_settings.camera.fov();

        MotionTrackingConfig {
            decoder: (
                self.create_decoder_state.config.clone(),
                self.app_state.is_some(),
            ),
            draw_grid: self.draw_grid,
            view_fov: self.camera_controller.fov_y,
            view_focus_point: {
                let p = self.camera_controller.focus_point;
                (p.x, p.y, p.z)
            },
            view_rot: self.camera_controller.rot.euler_angles(),
            view_dist: self.camera_controller.dist,
            estimators: self
                .estimator_uis
                .iter()
                .map(|ui| ui.config.clone())
                .zip(self.app_settings.settings.iter())
                .map(|(cfg, (_, loaded, settings))| {
                    (cfg, loaded.load(Ordering::Relaxed), *settings)
                })
                .collect(),
            camera_fov_x,
            camera_fov_y,
        }
    }
}

impl OfpsCtxApp for MotionTrackingApp {
    fn name(&self) -> &str {
        "Tracking"
    }

    fn late_update(
        &mut self,
        ctx: &Context,
        ofps_ctx: &Arc<OfpsAppContext>,
        frame: &Frame,
        renderer: &mut Renderer,
    ) {
        self.camera_controller.update(ctx);
    }

    fn update(
        &mut self,
        ctx: &Context,
        ofps_ctx: &Arc<OfpsAppContext>,
        frame: &Frame,
        renderer: &mut Renderer,
    ) {
        self.tracking_step(renderer);

        self.render(renderer);

        egui::SidePanel::left("tracking_settings").show(ctx, |ui| {
            egui::trace!(ui);

            let mut config_state = std::mem::take(&mut self.config_state);
            config_state.run(
                ui,
                "Tracking",
                Self::load_cfg,
                Self::save_cfg,
                self,
                ofps_ctx,
            );
            self.config_state = config_state;

            ui.separator();

            ui.heading("UI:");

            ui.separator();

            Grid::new(format!("tracking_ui")).show(ui, |ui| {
                ui.checkbox(&mut self.draw_grid, "Draw grid");
                ui.end_row();

                ui.label("View FOV");

                ui.add(Slider::new(&mut self.camera_controller.fov_y, 0.01..=179.0));
                ui.end_row();
            });

            ui.separator();

            ui.heading("Decoder:");

            ui.separator();

            if let Some(_) = &mut self.app_state {
                if ui.button("Close decoder").clicked() {
                    self.app_state = None;
                }
            } else {
                match DecoderPlugin::create_plugin_ui(
                    ui,
                    ofps_ctx,
                    &mut self.create_decoder_state,
                    0,
                    |_| {},
                ) {
                    Some(Ok(decoder)) => {
                        self.app_state =
                            Some(TrackingState::worker(decoder, self.app_settings.clone()))
                    }
                    _ => {}
                }
            }

            ui.separator();

            ui.heading("Camera:");

            ui.separator();

            Grid::new(format!("camera_settings")).show(ui, |ui| {
                let (mut fov_x, mut fov_y) = self.app_settings.camera.fov();

                ui.label("Horizontal FOV");
                ui.add(Slider::new(&mut fov_x, 0.01..=179.0));
                ui.end_row();

                ui.label("Vertical FOV");
                ui.add(Slider::new(&mut fov_y, 0.01..=179.0));
                ui.end_row();

                self.app_settings.camera = StandardCamera::new(fov_x, fov_y);
            });

            ui.separator();

            ui.heading("Estimators:");

            ui.separator();

            let mut to_remove = None;

            {
                for (i, (state, (est, exists, settings))) in self
                    .estimator_uis
                    .iter_mut()
                    .zip(self.app_settings.settings.iter_mut())
                    .enumerate()
                {
                    let is_some = exists.load(Ordering::Relaxed);

                    Grid::new(format!("estimator_ui_{i}")).show(ui, |ui| {
                        ui.label(format!("Estimator #{}", i));
                        ui.end_row();

                        ui.checkbox(&mut settings.layer_frames, "Draw frames");
                        ui.end_row();
                        ui.label("Angle delta");
                        ui.add(
                            Slider::new(&mut settings.layer_angle_delta, 0.01..=90.0)
                                .step_by(0.01)
                                .logarithmic(true),
                        );
                        ui.end_row();

                        ui.label("Keep frames");
                        ui.add(Slider::new(&mut settings.keep_frames, 1..=1000));
                        ui.end_row();

                        ui.label("Position scale");
                        ui.add(Slider::new(&mut settings.scale_factor, 0.00..=10.0));
                        ui.end_row();

                        ui.label("Frame offset");
                        ui.add(
                            Slider::new(&mut settings.camera_offset, 0.00..=100.0).step_by(0.01),
                        );
                        ui.end_row();

                        if is_some {
                            if ui.button("Stop").clicked() {
                                *est.lock().unwrap() = None;
                                exists.store(false, Ordering::Relaxed);
                            }
                            if ui.button("Remove").clicked() {
                                to_remove = Some(i);
                            }
                            ui.end_row();
                        }
                    });

                    if !is_some {
                        match EstimatorPlugin::create_plugin_ui(ui, ofps_ctx, state, i + 1, |ui| {
                            if ui.button("Remove").clicked() {
                                to_remove = Some(i);
                            }
                        }) {
                            Some(Ok(new_estimator)) => {
                                *est.lock().unwrap() = Some(new_estimator);
                                exists.store(true, Ordering::Relaxed);
                            }
                            _ => {}
                        }
                    }

                    ui.separator();
                }

                if let Some(to_remove) = to_remove {
                    self.app_settings.settings.remove(to_remove);
                    self.estimator_uis.remove(to_remove);
                }

                if ui.button("New estimator").clicked() {
                    self.app_settings.settings.push(Default::default());
                    self.estimator_uis.push(Default::default());
                }

                if let Some(Ok(mut settings)) = self.app_state.as_ref().map(|a| a.worker.settings())
                {
                    *settings = self.app_settings.clone();
                }
            }
        });
    }
}
